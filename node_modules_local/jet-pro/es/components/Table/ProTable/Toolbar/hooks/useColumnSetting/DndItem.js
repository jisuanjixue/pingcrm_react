function _slicedToArray(arr, i) {
  return (
    _arrayWithHoles(arr) ||
    _iterableToArrayLimit(arr, i) ||
    _unsupportedIterableToArray(arr, i) ||
    _nonIterableRest()
  );
}
function _nonIterableRest() {
  throw new TypeError(
    'Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.',
  );
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === 'Object' && o.constructor) n = o.constructor.name;
  if (n === 'Map' || n === 'Set') return Array.from(o);
  if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i =
    null == arr
      ? null
      : ('undefined' != typeof Symbol && arr[Symbol.iterator]) || arr['@@iterator'];
  if (null != _i) {
    var _s,
      _e,
      _x,
      _r,
      _arr = [],
      _n = !0,
      _d = !1;
    try {
      if (((_x = (_i = _i.call(arr)).next), 0 === i)) {
        if (Object(_i) !== _i) return;
        _n = !1;
      } else
        for (
          ;
          !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i);
          _n = !0
        );
    } catch (err) {
      (_d = !0), (_e = err);
    } finally {
      try {
        if (!_n && null != _i.return && ((_r = _i.return()), Object(_r) !== _r)) return;
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
import {
  MenuOutlined,
  VerticalAlignBottomOutlined,
  VerticalAlignMiddleOutlined,
  VerticalAlignTopOutlined,
} from '@ant-design/icons';
import { Button, theme, Tooltip } from 'antd';
// import useToken from 'antd/es/theme/useToken';
import Checkbox from 'antd/lib/checkbox/Checkbox';
import React, { useRef } from 'react';
import { useDrag, useDrop } from 'react-dnd';
import { genColumnTitle } from '../../../utils';
export default (function (_ref) {
  var type = _ref.type,
    hiddenKeys = _ref.hiddenKeys,
    currentHoverIndex = _ref.currentHoverIndex,
    index = _ref.index,
    column = _ref.column,
    onDrop = _ref.onDrop,
    setCurrentHoverIndex = _ref.setCurrentHoverIndex,
    toggleKeyHide = _ref.toggleKeyHide,
    onColumnFixed = _ref.onColumnFixed;
  // const [, antdToken] = useToken();
  var ref = useRef(null);
  var refDirection = useRef();
  var _useDrop = useDrop(
      function () {
        return {
          accept: type,
          collect: function collect(monitor) {
            return {
              handlerId: monitor.getHandlerId(),
            };
          },
          hover: function hover(item, monitor) {
            var _ref$current;
            if (!ref.current) return;
            var dragIndex = item.index;
            var hoverIndex = index;

            // Don't replace items with themselves
            // if (dragIndex === hoverIndex) return;

            // Determine rectangle on screen
            var hoverBoundingRect =
              (_ref$current = ref.current) === null || _ref$current === void 0
                ? void 0
                : _ref$current.getBoundingClientRect();
            // Get vertical middle
            var hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
            // Determine mouse position
            var clientOffset = monitor.getClientOffset();
            // Get pixels to the top
            var hoverClientY = clientOffset.y - hoverBoundingRect.top;
            // Only perform the move when the mouse has crossed half of the items height
            // When dragging downwards, only move when the cursor is below 50%
            // When dragging upwards, only move when the cursor is above 50%

            // Dragging downwards
            if (dragIndex < hoverIndex && hoverClientY < hoverMiddleY) {
              refDirection.current = 'down';
            }

            // Dragging upwards
            else if (dragIndex > hoverIndex && hoverClientY > hoverMiddleY) {
              refDirection.current = 'up';
            }
            setCurrentHoverIndex(hoverIndex);

            // Time to actually perform the action
            // Note: we're mutating the monitor item here!
            // Generally it's better to avoid mutations,
            // but it's good here for the sake of performance
            // to avoid expensive index searches.
          },

          drop: function drop(item) {
            onDrop(item.index, index);
          },
        };
      },
      [onDrop],
    ),
    _useDrop2 = _slicedToArray(_useDrop, 2),
    handlerId = _useDrop2[0].handlerId,
    drop = _useDrop2[1];
  var _useDrag = useDrag(
      function () {
        return {
          type: type,
          item: {
            type: type,
            index: index,
            column: column,
          },
          collect: function collect(monitor) {
            return {
              isDragging: monitor.isDragging(),
            };
          },
          end: function end(_, monitor) {
            if (!monitor.didDrop()) setCurrentHoverIndex(undefined);
          },
        };
      },
      [column.key, index],
    ),
    _useDrag2 = _slicedToArray(_useDrag, 2),
    isDragging = _useDrag2[0].isDragging,
    drag = _useDrag2[1];
  var opacity = isDragging ? 0.5 : 1;
  drag(drop(ref));
  var Indicator = function Indicator(_ref2) {
    var direction = _ref2.direction,
      itemIndex = _ref2.itemIndex;
    return /*#__PURE__*/ React.createElement('div', {
      className: 'hover-indicator',
      style: {
        backgroundColor: theme.defaultConfig.token['colorPrimary'],
        // 'rgb(22, 119, 255)', //antdToken.colorPrimary,
        opacity: currentHoverIndex === itemIndex && refDirection.current === direction ? 1 : 0,
      },
    });
  };
  return /*#__PURE__*/ React.createElement(
    'li',
    {
      key: column.key,
      ref: ref,
      style: {
        cursor: 'move',
        opacity: opacity,
      },
      'data-handler-id': handlerId,
    },
    /*#__PURE__*/ React.createElement(Indicator, {
      direction: 'up',
      itemIndex: index,
    }),
    /*#__PURE__*/ React.createElement(
      'div',
      {
        style: {
          display: 'flex',
        },
      },
      /*#__PURE__*/ React.createElement(
        'div',
        {
          style: {
            flexDirection: 'column',
          },
        },
        /*#__PURE__*/ React.createElement(MenuOutlined, null),
      ),
      /*#__PURE__*/ React.createElement(
        'div',
        {
          style: {
            flexDirection: 'column',
            width: '100%',
          },
        },
        /*#__PURE__*/ React.createElement(
          Checkbox,
          {
            style: {
              width: '100%',
              marginLeft: 5,
            },
            value: column.key,
            checked: !hiddenKeys.some(function (k) {
              return k === column.key;
            }),
            onChange: function onChange() {
              return toggleKeyHide(column.key);
            },
          },
          genColumnTitle(column.title),
          /*#__PURE__*/ React.createElement(
            'span',
            {
              className: 'col-actions',
            },
            column.fixed &&
              /*#__PURE__*/ React.createElement(
                Tooltip,
                {
                  title: '\u4E0D\u56FA\u5B9A',
                },
                /*#__PURE__*/ React.createElement(Button, {
                  size: 'small',
                  type: 'link',
                  icon: /*#__PURE__*/ React.createElement(VerticalAlignMiddleOutlined, null),
                  onClick: function onClick() {
                    return onColumnFixed(column.key, false);
                  },
                }),
              ),
            (!column.fixed || column.fixed === 'right') &&
              /*#__PURE__*/ React.createElement(
                Tooltip,
                {
                  title: '\u56FA\u5B9A\u5728\u5DE6\u4FA7',
                },
                /*#__PURE__*/ React.createElement(Button, {
                  size: 'small',
                  type: 'link',
                  icon: /*#__PURE__*/ React.createElement(VerticalAlignTopOutlined, null),
                  onClick: function onClick() {
                    return onColumnFixed(column.key, 'left');
                  },
                }),
              ),
            (!column.fixed || column.fixed === 'left') &&
              /*#__PURE__*/ React.createElement(
                Tooltip,
                {
                  title: '\u56FA\u5B9A\u5728\u53F3\u4FA7',
                },
                /*#__PURE__*/ React.createElement(Button, {
                  size: 'small',
                  type: 'link',
                  icon: /*#__PURE__*/ React.createElement(VerticalAlignBottomOutlined, null),
                  onClick: function onClick() {
                    return onColumnFixed(column.key, 'right');
                  },
                }),
              ),
          ),
        ),
      ),
    ),
    /*#__PURE__*/ React.createElement(Indicator, {
      direction: 'down',
      itemIndex: index,
    }),
  );
});
